# 設計書: データ収集スケジューラ

## 概要

本ドキュメントは、完全サーバーレスの AWS アーキテクチャを使用して、外部 HTTP API のサブミニッツ（5 秒）ポーリングを実現する PoC データ収集スケジューラの設計を記述します。システムはメトリクスを DynamoDB に保存し、後で可視化できるようにします。

### 主要な設計決定

1. **時刻形式**: すべてのタイムスタンプに ISO8601 秒精度形式を使用（例：`2025-12-02T10:23:05Z`）
2. **AWS リージョン**: CDK コンテキスト/環境で設定可能（デフォルト：us-east-1）
3. **冪等性戦略**: 重複エントリを防ぐため、`attribute_not_exists`を使用した DynamoDB 条件付き書き込み
4. **モック API カウント式**: 可視パターンを作成するため、分の値に基づく決定論的計算

## アーキテクチャ

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           AWSクラウド                                        │
│                                                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐    ┌───────────┐  │
│  │ EventBridge  │───▶│   Sender     │───▶│    SQS       │───▶│ Collector │  │
│  │  (1分)       │    │   Lambda     │    │   キュー     │    │  Lambda   │  │
│  └──────────────┘    └──────────────┘    │ (12個の遅延  │    └─────┬─────┘  │
│                                          │  メッセージ) │          │        │
│                                          └──────────────┘          │        │
│                                                                    ▼        │
│                                                            ┌───────────┐    │
│                                                            │ DynamoDB  │    │
│                                                            │ テーブル  │    │
│                                                            └───────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     │ HTTP GET
                                     ▼
                          ┌─────────────────────┐
                          │  モックAIエンプロイー │
                          │  API (localhost)    │
                          │  :3000              │
                          └─────────────────────┘
```

### サブミニッツスケジューリングフロー

```
N分目:
├── EventBridgeがSender Lambdaをトリガー
├── Sender Lambdaが12個のSQSメッセージを送信:
│   ├── メッセージ1: DelaySeconds=0  → CollectorがN+0秒で実行
│   ├── メッセージ2: DelaySeconds=5  → CollectorがN+5秒で実行
│   ├── メッセージ3: DelaySeconds=10 → CollectorがN+10秒で実行
│   ├── ...
│   └── メッセージ12: DelaySeconds=55 → CollectorがN+55秒で実行
└── 各メッセージは遅延が終了するとCollector Lambdaをトリガー
```

## コンポーネントとインターフェース

### 1. Sender Lambda

**目的**: 1 分間に 5 秒間隔のポーリングを作成するため、12 個の遅延 SQS メッセージを生成する。各メッセージには対象時間幅（FROM, TO）を含める。

**インターフェース**:

```typescript
// 入力: EventBridgeスケジュールイベント（毎分0秒にトリガー）
// 出力: void（副作用：12個のSQSメッセージ送信）

interface SenderConfig {
  queueUrl: string; // 環境変数からのSQSキューURL
  intervalSeconds: number; // 5秒
  messagesPerMinute: number; // 12メッセージ
}

interface ScheduleMessage {
  from: string; // ISO8601タイムスタンプ（時間幅の開始）
  to: string; // ISO8601タイムスタンプ（時間幅の終了）
}
```

**動作**:

1. EventBridge トリガー時刻（毎分 0 秒）を基準時刻として取得
2. 12 個のスロットを計算:
   - スロット 0: from=基準時刻+0 秒, to=基準時刻+5 秒, delay=0
   - スロット 1: from=基準時刻+5 秒, to=基準時刻+10 秒, delay=5
   - ...
   - スロット 11: from=基準時刻+55 秒, to=基準時刻+60 秒, delay=55
3. 対応する`DelaySeconds`で各メッセージを SQS に送信
4. デバッグ用に送信した各メッセージをログ記録
5. 1 つが失敗しても残りのメッセージの処理を続行

### 2. Collector Lambda

**目的**: SQS メッセージから時間幅を受け取り、AI エンプロイー API からメトリクスを取得し、DynamoDB に保存する。

**インターフェース**:

```typescript
// 入力: 時間幅（from, to）を含むSQSイベント
// 出力: void（副作用：DynamoDBレコード書き込み）

interface CollectorConfig {
  apiBaseUrl: string; // AI_API_BASE_URL環境変数
  tableName: string; // AI_METRICS_TABLE_NAME環境変数
}

interface ScheduleMessage {
  from: string; // ISO8601タイムスタンプ（時間幅の開始）
  to: string; // ISO8601タイムスタンプ（時間幅の終了）
}

interface ApiResponse {
  from: string;
  to: string;
  count: number;
}

interface MetricRecord {
  metricName: string; // パーティションキー: "ai_response_count"
  slotTime: string; // ソートキー: fromのISO8601（5秒境界）
  count: number;
}
```

**動作**:

1. SQS メッセージから時間幅（from, to）を取得
2. `from`をスロットタイムとして使用（既に 5 秒境界に揃っている）
3. API を呼び出し: `GET {baseUrl}/response_count?from={from}&to={to}`
4. JSON レスポンスをパース
5. 冪等な条件式で DynamoDB に書き込み
6. デバッグ用にすべての操作をログ記録

### 3. モック AI エンプロイー API

**目的**: 収集パイプライン用の決定論的テストデータを提供する。

**インターフェース**:

```typescript
// エンドポイント: GET /response_count
// クエリパラメータ: from (ISO8601), to (ISO8601)
// レスポンス: { from: string, to: string, count: number }

interface ResponseCountQuery {
  from: string; // ISO8601日時
  to: string; // ISO8601日時
}

interface ResponseCountResult {
  from: string;
  to: string;
  count: number; // 0-10、時刻に基づく決定論的値
}
```

**カウント式**（決定論的）:

```typescript
// 可視パターンを作成するため分の値を使用
const minute = new Date(to).getMinutes();
const count = minute % 11; // 11分ごとに0-10の値が循環
```

### 4. スロットタイム計算機

**目的**: タイムスタンプを 5 秒境界に切り捨てる純粋関数。

**インターフェース**:

```typescript
function calculateSlotTime(timestamp: Date): string;
// 入力: 任意のDate
// 出力: 秒を5の倍数に切り捨てたISO8601文字列
// 例: 2025-12-02T10:23:07Z → "2025-12-02T10:23:05Z"
```

**アルゴリズム**:

```typescript
const seconds = timestamp.getUTCSeconds();
const truncatedSeconds = Math.floor(seconds / 5) * 5;
// 秒を切り捨て値に、ミリ秒を0に設定
// ISO8601文字列を返す
```

## データモデル

### DynamoDB テーブル: AiResponseMetrics

| 属性       | 型     | キータイプ         | 説明                                        |
| ---------- | ------ | ------------------ | ------------------------------------------- |
| metricName | String | パーティションキー | メトリクス識別子（例："ai_response_count"） |
| slotTime   | String | ソートキー         | 5 秒境界に切り捨てた ISO8601 タイムスタンプ |
| count      | Number | -                  | API からのレスポンス数                      |

**レコード例**:

```json
{
  "metricName": "ai_response_count",
  "slotTime": "2025-12-02T10:23:05Z",
  "count": 7
}
```

### SQS メッセージスキーマ

```json
{
  "from": "2025-12-02T10:23:00Z",
  "to": "2025-12-02T10:23:05Z"
}
```

## 正確性プロパティ

_プロパティとは、システムのすべての有効な実行において真であるべき特性または動作です。本質的に、システムが何をすべきかについての形式的な記述です。プロパティは、人間が読める仕様と機械で検証可能な正確性保証の橋渡しをします。_

### プロパティ 1: Sender が正しい遅延シーケンスを生成

*任意の*Sender Lambda 実行において、関数は正確に 12 個のメッセージを生成し、DelaySeconds 値は[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55]のシーケンスを形成するものとする。

**検証対象: 要件 1.2**

### プロパティ 2: Sender のタイムウィンドウ生成の正確性

*任意の*基準時刻（毎分 0 秒）において、Sender Lambda が生成する 12 個のメッセージは、それぞれ正確に 5 秒間隔の連続した時間幅（from, to）を持ち、`to - from = 5秒`かつ`from < to`であるものとする。

**検証対象: 要件 1.2, 2.1**

### プロパティ 3: ISO8601 形式での API URL 構築

*任意の*有効な from/to 日付を持つタイムウィンドウにおいて、構築された URL は適切にフォーマットされた ISO8601 クエリパラメータを含み、同等のタイムスタンプにパースバック可能であるものとする。

**検証対象: 要件 2.3**

### プロパティ 4: API レスポンスパースのラウンドトリップ

_任意の_`from`、`to`、`count`フィールドを含む有効な JSON レスポンスにおいて、パースは同等の値を持つ構造化オブジェクトを生成し、同等の JSON にシリアライズバック可能であるものとする。

**検証対象: 要件 2.4**

### プロパティ 5: スロットタイムの 5 秒境界への切り捨て

*任意の*タイムスタンプにおいて、計算されたスロットタイムは秒が 5 の倍数であり、元のタイムスタンプ以下であり、元のタイムスタンプとの差が 5 秒未満であるものとする。

**検証対象: 要件 4.1, 3.2**

### プロパティ 6: スロットタイム ISO8601 形式

*任意の*計算されたスロットタイムにおいて、出力文字列は ISO8601 パターン`YYYY-MM-DDTHH:mm:ssZ`に一致し、同等の Date にパースバック可能であるものとする。

**検証対象: 要件 4.3**

### プロパティ 7: モック API レスポンス構造と境界

*任意の*有効なタイムウィンドウクエリにおいて、レスポンスは`from`、`to`、`count`フィールドを含み、count は 0 から 10 の整数であり、同じ入力は常に同じ count を生成する（決定論性）ものとする。

**検証対象: 要件 5.1, 5.2**

### プロパティ 8: モック API の ISO8601 パース

*任意の*有効な ISO8601 日時文字列において、モック API はそれを Date オブジェクトにパースし、ISO8601 にフォーマットバックすると同等のタイムスタンプを生成するものとする。

**検証対象: 要件 5.3**

### プロパティ 9: 冪等な DynamoDB 書き込み

*任意の*メトリクスレコードにおいて、同じレコード（同じ metricName と slotTime）を複数回書き込むと、テーブルには一貫したデータを持つ正確に 1 つのレコードが存在するものとする。

**検証対象: 要件 3.4**

## エラーハンドリング

### Sender Lambda エラー

| エラーシナリオ       | ハンドリング戦略                                   |
| -------------------- | -------------------------------------------------- |
| SQS SendMessage 失敗 | エラーをログ記録、残りのメッセージを続行           |
| 無効なキュー URL     | エラーをログ記録、例外をスロー（フェイルファスト） |

### Collector Lambda エラー

| エラーシナリオ                                | ハンドリング戦略                                             |
| --------------------------------------------- | ------------------------------------------------------------ |
| API 呼び出し失敗（ネットワーク/タイムアウト） | エラー詳細をログ記録、SQS リトライをトリガーするため再スロー |
| API が非 200 ステータスを返す                 | エラー詳細をログ記録、SQS リトライをトリガーするため再スロー |
| API が無効な JSON を返す                      | エラー詳細をログ記録、SQS リトライをトリガーするため再スロー |
| DynamoDB 書き込み失敗                         | エラー詳細をログ記録、SQS リトライをトリガーするため再スロー |
| 条件チェック失敗（重複）                      | 情報としてログ記録（冪等性のため想定内）、成功               |

### モック API エラー

| エラーシナリオ       | ハンドリング戦略                |
| -------------------- | ------------------------------- |
| クエリパラメータ欠落 | エラーメッセージ付き 400 を返す |
| 無効な ISO8601 形式  | エラーメッセージ付き 400 を返す |

## テスト戦略

### プロパティベーステストライブラリ

**ライブラリ**: TypeScript 用[fast-check](https://github.com/dubzzz/fast-check)

**設定**: プロパティテストごとに最低 100 回の反復

### プロパティベーステスト

各正確性プロパティは fast-check を使用したプロパティベーステストとして実装されます：

1. **Sender 遅延シーケンス** - 任意の実行コンテキストを生成、正しい遅延を持つ 12 メッセージを検証
2. **タイムウィンドウ計算** - 任意のタイムスタンプとウィンドウサイズを生成、from/to 関係を検証
3. **URL 構築** - 任意のタイムウィンドウを生成、ISO8601 フォーマットとパース可能性を検証
4. **レスポンスパース** - 任意の有効な JSON レスポンスを生成、ラウンドトリップ一貫性を検証
5. **スロットタイム切り捨て** - 任意のタイムスタンプを生成、5 秒境界揃えを検証
6. **スロットタイムフォーマット** - 任意のスロットタイムを生成、ISO8601 形式とパース可能性を検証
7. **モック API レスポンス** - 任意のタイムウィンドウを生成、レスポンス構造と決定論性を検証
8. **ISO8601 パース** - 任意の有効な ISO8601 文字列を生成、パース/フォーマットラウンドトリップを検証
9. **冪等書き込み** - 任意のレコードを生成、複数書き込み後の単一レコードを検証

### ユニットテスト

ユニットテストは以下をカバーします：

1. **スロットタイム計算のエッジケース**:

   - 正確に 5 秒境界上のタイムスタンプ
   - 分/時境界のタイムスタンプ
   - ミリ秒を持つタイムスタンプ

2. **エラーハンドリングパス**:

   - API タイムアウトシミュレーション
   - 無効な JSON レスポンス
   - DynamoDB 条件チェック失敗

3. **設定読み込み**:
   - 環境変数のデフォルト値
   - 必須設定の欠落

### 統合テスト（手動）

PoC では、統合テストは手動で行います：

1. CDK スタックをデプロイ
2. モック API をローカルで起動
3. CloudWatch ログで Lambda 実行を観察
4. DynamoDB をクエリしてレコードを検証

### テストアノテーション形式

すべてのプロパティベーステストには以下のコメント形式を含める必要があります：

```typescript
// **Feature: data-collection-scheduler, Property {N}: {property_text}**
```
