# 要件定義書

## はじめに

本ドキュメントは、外部 HTTP API を 5 秒間隔でポーリングし、結果を DynamoDB に保存するデータ収集スケジューラの PoC（概念実証）の要件を定義します。EventBridge、SQS、Lambda を使用した完全サーバーレスの AWS アーキテクチャで、5 秒間隔のポーリングを実現します。テスト用のデータソースとして、モック「AI エンプロイー」HTTP API を使用します。

## 用語集

- **Collector Lambda**: AI エンプロイー API からデータを取得し、DynamoDB に保存する AWS Lambda 関数
- **Sender Lambda**: サブミニッツスケジューリングを実現するため、12 個の遅延 SQS メッセージを生成する AWS Lambda 関数
- **AI エンプロイー API**: 指定された時間枠のレスポンス数を返すモック HTTP サーバー
- **スロットタイム**: DynamoDB のソートキーとして使用される 5 秒単位に揃えられたタイムスタンプ（例：2025-12-02T10:23:05Z）
- **タイムウィンドウ**: レスポンス数を照会するための`from`と`to`タイムスタンプで定義される 5 秒間の期間
- **サブミニッツスケジューリング**: EventBridge の 1 分最小間隔より短いポーリング間隔を実現するため、SQS 遅延メッセージを使用するパターン

## 要件

### 要件 1: サブミニッツスケジューリングパターン

**ユーザーストーリー:** システム運用者として、外部 API を 5 秒ごとにポーリングしたい。これにより、きめ細かいメトリクスデータを収集できる。

#### 受け入れ基準

1. EventBridge ルールが毎分 0 秒にトリガーされた時、Sender Lambda は正確に 1 回呼び出されるものとする
2. Sender Lambda が実行された時、Sender Lambda は SQS キューに正確に 12 個のメッセージを送信するものとする。各メッセージには対象時間幅（`from`と`to`）を含め、DelaySeconds の値は 0、5、10、15、20、25、30、35、40、45、50、55 とする
3. Sender Lambda が時間幅を生成する時、各メッセージの時間幅は 5 秒間隔で連続するものとする（例：0-5 秒、5-10 秒、...、55-60 秒）
4. SQS メッセージが利用可能になった時、Collector Lambda はそのメッセージを処理するために呼び出されるものとする
5. スケジューリングシステムが 1 分間動作した時、Collector Lambda は約 12 回呼び出されるものとする

### 要件 2: Collector Lambda のデータ取得

**ユーザーストーリー:** データアナリストとして、コレクターが AI エンプロイー API からレスポンス数を取得してほしい。これにより、5 秒ウィンドウごとのメトリクスが記録される。

#### 受け入れ基準

1. Collector Lambda が実行された時、Collector Lambda は SQS メッセージから時間幅（`from`と`to`）を取得するものとする
2. Collector Lambda が時間幅を取得した後、Collector Lambda は ISO8601 形式の`from`と`to`クエリパラメータを使用して GET {AI_API_BASE_URL}/response_count を呼び出すものとする
3. AI エンプロイー API がレスポンスを返した時、Collector Lambda は`from`、`to`、`count`フィールドを含む JSON レスポンスをパースするものとする

### 要件 3: DynamoDB ストレージ

**ユーザーストーリー:** データアナリストとして、メトリクスを 5 秒粒度で DynamoDB に保存してほしい。これにより、後でデータをクエリして可視化できる。

#### 受け入れ基準

1. Collector Lambda が有効な API レスポンスを受信した時、Collector Lambda はパーティションキー`metricName`を"ai_response_count"に設定して DynamoDB にレコードを書き込むものとする
2. Collector Lambda がレコードを書き込む時、Collector Lambda はソートキー`slotTime`を最も近い 5 秒境界に切り捨てた ISO8601 タイムスタンプに設定するものとする
3. Collector Lambda がレコードを書き込む時、Collector Lambda は API レスポンスからの数値として`count`属性を保存するものとする
4. Collector Lambda が既存のスロットにレコードを書き込もうとした時、Collector Lambda は重複や二重カウントを防ぐ冪等な書き込み操作を使用するものとする

### 要件 4: スロットタイム計算

**ユーザーストーリー:** 開発者として、スロットタイムを 5 秒境界に揃えたい。これにより、データ集計が一貫して予測可能になる。

#### 受け入れ基準

1. タイムスタンプからスロットタイムを計算する時、システムは秒を最も近い 5 の倍数に切り捨てるものとする（例：07 は 05 に、13 は 10 になる）
2. タイムスタンプの秒が正確に 5 秒境界上にある時、システムはその境界値を変更せずに保持するものとする
3. スロットタイムをフォーマットする時、システムは秒精度の ISO8601 形式で出力するものとする（例：2025-12-02T10:23:05Z）

### 要件 5: モック AI エンプロイー API

**ユーザーストーリー:** 開発者として、決定論的なレスポンス数を返すモック API が欲しい。これにより、データ収集パイプラインをエンドツーエンドでテストできる。

#### 受け入れ基準

1. 有効な`from`と`to`クエリパラメータを持つ GET リクエストが/response_count に送信された時、モック API は`from`、`to`、`count`フィールドを含む JSON レスポンスを返すものとする
2. モック API がカウントを計算する時、モック API はタイムウィンドウに基づく決定論的な式を使用して 0 から 10 の間の値を生成するものとする
3. モック API がリクエストを受信した時、モック API は`from`と`to`パラメータを ISO8601 日時文字列としてパースするものとする
4. モック API が起動した時、モック API はポート 3000 でリッスンするものとする

### 要件 6: Infrastructure as Code

**ユーザーストーリー:** DevOps エンジニアとして、すべての AWS リソースを CDK TypeScript で定義したい。これにより、インフラストラクチャがバージョン管理され、再現可能になる。

#### 受け入れ基準

1. CDK スタックが合成された時、スタックはパーティションキー`metricName`（文字列）とソートキー`slotTime`（文字列）を持つ DynamoDB テーブルを定義するものとする
2. CDK スタックが合成された時、スタックはスケジューリングメッセージ用の SQS キューを定義するものとする
3. CDK スタックが合成された時、スタックは SQS キューへのメッセージ送信権限を持つ Sender Lambda を定義するものとする
4. CDK スタックが合成された時、スタックは DynamoDB への書き込み権限を持つ Collector Lambda を定義するものとする
5. CDK スタックが合成された時、スタックは 1 分ごとに Sender Lambda をトリガーする EventBridge ルールを定義するものとする
6. CDK スタックが合成された時、スタックは Lambda 関数を Node.js 20.x ランタイムで設定するものとする

### 要件 7: エラーハンドリングとロギング

**ユーザーストーリー:** 開発者として、Lambda 関数に基本的なエラーハンドリングとロギングが欲しい。これにより、テスト中の問題をデバッグできる。

#### 受け入れ基準

1. Collector Lambda が AI エンプロイー API の呼び出しに失敗した時、Collector Lambda はエラー詳細をログに記録し、例外を再スローするものとする
2. Collector Lambda が DynamoDB への書き込みに失敗した時、Collector Lambda はエラー詳細をログに記録し、例外を再スローするものとする
3. Sender Lambda が SQS メッセージの送信に失敗した時、Sender Lambda はエラー詳細をログに記録し、残りのメッセージの処理を続行するものとする
4. Lambda 関数が実行された時、Lambda 関数はタイムスタンプと関連パラメータを含む主要な操作詳細をログに記録するものとする
