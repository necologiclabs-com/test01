import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import { generateDelayedMessages } from './index';

describe('Sender Lambda Property Tests', () => {
    /**
     * **Feature: data-collection-scheduler, Property 1: Senderが正しい遅延シーケンスを生成**
     * **Validates: Requirements 1.2**
     * 
     * For any Sender Lambda execution, the function must generate exactly 12 messages
     * with DelaySeconds values forming the sequence [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55]
     */
    it('Property 1: generates correct delay sequence', () => {
        fc.assert(
            fc.property(
                // Generate arbitrary reference times (minute boundaries)
                fc.date({ min: new Date('2020-01-01'), max: new Date('2030-12-31') }),
                (timestamp) => {
                    // Ensure minute boundary (0 seconds, 0 milliseconds)
                    const referenceTime = new Date(timestamp);
                    referenceTime.setUTCSeconds(0, 0);

                    const intervalSeconds = 5;
                    const messagesPerMinute = 12;

                    const messages = generateDelayedMessages(
                        referenceTime,
                        intervalSeconds,
                        messagesPerMinute
                    );

                    // Check 1: Must generate exactly 12 messages
                    expect(messages).toHaveLength(12);

                    // Check 2: DelaySeconds must form the sequence [0, 5, 10, ..., 55]
                    const expectedDelays = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55];
                    const actualDelays = messages.map(m => m.delaySeconds);
                    expect(actualDelays).toEqual(expectedDelays);

                    // Check 3: Each delay must be correct (i * intervalSeconds)
                    messages.forEach((msg, index) => {
                        expect(msg.delaySeconds).toBe(index * intervalSeconds);
                    });
                }
            ),
            { numRuns: 100 }
        );
    });

    /**
     * **Feature: data-collection-scheduler, Property 2: Senderのタイムウィンドウ生成の正確性**
     * **Validates: Requirements 1.2, 2.1**
     * 
     * For any reference time (minute boundary), the 12 messages generated by Sender Lambda
     * must each have consecutive 5-second time windows where:
     * - to - from = 5 seconds
     * - from < to
     * - Windows are consecutive (message[i].to === message[i+1].from)
     */
    it('Property 2: generates accurate time windows', () => {
        fc.assert(
            fc.property(
                // Generate arbitrary reference times
                fc.date({ min: new Date('2020-01-01'), max: new Date('2030-12-31') }),
                (timestamp) => {
                    // Ensure minute boundary
                    const referenceTime = new Date(timestamp);
                    referenceTime.setUTCSeconds(0, 0);

                    const intervalSeconds = 5;
                    const messagesPerMinute = 12;

                    const messages = generateDelayedMessages(
                        referenceTime,
                        intervalSeconds,
                        messagesPerMinute
                    );

                    messages.forEach((msg, index) => {
                        const fromDate = new Date(msg.message.from);
                        const toDate = new Date(msg.message.to);

                        // Check 1: to - from = 5 seconds (5000 milliseconds)
                        const duration = toDate.getTime() - fromDate.getTime();
                        expect(duration).toBe(5000);

                        // Check 2: from < to
                        expect(fromDate.getTime()).toBeLessThan(toDate.getTime());

                        // Check 3: from time should be referenceTime + (index * intervalSeconds)
                        const expectedFrom = new Date(referenceTime);
                        expectedFrom.setUTCSeconds(index * intervalSeconds);
                        expect(fromDate.getTime()).toBe(expectedFrom.getTime());

                        // Check 4: to time should be referenceTime + ((index + 1) * intervalSeconds)
                        const expectedTo = new Date(referenceTime);
                        expectedTo.setUTCSeconds((index + 1) * intervalSeconds);
                        expect(toDate.getTime()).toBe(expectedTo.getTime());

                        // Check 5: Windows are consecutive (except for last message)
                        if (index < messages.length - 1) {
                            const nextFromDate = new Date(messages[index + 1].message.from);
                            expect(toDate.getTime()).toBe(nextFromDate.getTime());
                        }
                    });

                    // Check 6: First message starts at reference time
                    const firstFrom = new Date(messages[0].message.from);
                    expect(firstFrom.getTime()).toBe(referenceTime.getTime());

                    // Check 7: Last message ends at reference time + 60 seconds
                    const lastTo = new Date(messages[11].message.to);
                    const expectedEnd = new Date(referenceTime);
                    expectedEnd.setUTCSeconds(60);
                    expect(lastTo.getTime()).toBe(expectedEnd.getTime());
                }
            ),
            { numRuns: 100 }
        );
    });
});
