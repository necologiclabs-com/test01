"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const fc = __importStar(require("fast-check"));
const index_1 = require("./index");
(0, vitest_1.describe)('Sender Lambda Property Tests', () => {
    /**
     * **Feature: data-collection-scheduler, Property 1: Senderが正しい遅延シーケンスを生成**
     * **Validates: Requirements 1.2**
     *
     * For any Sender Lambda execution, the function must generate exactly 12 messages
     * with DelaySeconds values forming the sequence [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55]
     */
    (0, vitest_1.it)('Property 1: generates correct delay sequence', () => {
        fc.assert(fc.property(
        // Generate arbitrary reference times (minute boundaries)
        fc.date({ min: new Date('2020-01-01'), max: new Date('2030-12-31') }), (timestamp) => {
            // Ensure minute boundary (0 seconds, 0 milliseconds)
            const referenceTime = new Date(timestamp);
            referenceTime.setUTCSeconds(0, 0);
            const intervalSeconds = 5;
            const messagesPerMinute = 12;
            const messages = (0, index_1.generateDelayedMessages)(referenceTime, intervalSeconds, messagesPerMinute);
            // Check 1: Must generate exactly 12 messages
            (0, vitest_1.expect)(messages).toHaveLength(12);
            // Check 2: DelaySeconds must form the sequence [0, 5, 10, ..., 55]
            const expectedDelays = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55];
            const actualDelays = messages.map(m => m.delaySeconds);
            (0, vitest_1.expect)(actualDelays).toEqual(expectedDelays);
            // Check 3: Each delay must be correct (i * intervalSeconds)
            messages.forEach((msg, index) => {
                (0, vitest_1.expect)(msg.delaySeconds).toBe(index * intervalSeconds);
            });
        }), { numRuns: 100 });
    });
    /**
     * **Feature: data-collection-scheduler, Property 2: Senderのタイムウィンドウ生成の正確性**
     * **Validates: Requirements 1.2, 2.1**
     *
     * For any reference time (minute boundary), the 12 messages generated by Sender Lambda
     * must each have consecutive 5-second time windows where:
     * - to - from = 5 seconds
     * - from < to
     * - Windows are consecutive (message[i].to === message[i+1].from)
     */
    (0, vitest_1.it)('Property 2: generates accurate time windows', () => {
        fc.assert(fc.property(
        // Generate arbitrary reference times
        fc.date({ min: new Date('2020-01-01'), max: new Date('2030-12-31') }), (timestamp) => {
            // Ensure minute boundary
            const referenceTime = new Date(timestamp);
            referenceTime.setUTCSeconds(0, 0);
            const intervalSeconds = 5;
            const messagesPerMinute = 12;
            const messages = (0, index_1.generateDelayedMessages)(referenceTime, intervalSeconds, messagesPerMinute);
            messages.forEach((msg, index) => {
                const fromDate = new Date(msg.message.from);
                const toDate = new Date(msg.message.to);
                // Check 1: to - from = 5 seconds (5000 milliseconds)
                const duration = toDate.getTime() - fromDate.getTime();
                (0, vitest_1.expect)(duration).toBe(5000);
                // Check 2: from < to
                (0, vitest_1.expect)(fromDate.getTime()).toBeLessThan(toDate.getTime());
                // Check 3: from time should be referenceTime + (index * intervalSeconds)
                const expectedFrom = new Date(referenceTime);
                expectedFrom.setUTCSeconds(index * intervalSeconds);
                (0, vitest_1.expect)(fromDate.getTime()).toBe(expectedFrom.getTime());
                // Check 4: to time should be referenceTime + ((index + 1) * intervalSeconds)
                const expectedTo = new Date(referenceTime);
                expectedTo.setUTCSeconds((index + 1) * intervalSeconds);
                (0, vitest_1.expect)(toDate.getTime()).toBe(expectedTo.getTime());
                // Check 5: Windows are consecutive (except for last message)
                if (index < messages.length - 1) {
                    const nextFromDate = new Date(messages[index + 1].message.from);
                    (0, vitest_1.expect)(toDate.getTime()).toBe(nextFromDate.getTime());
                }
            });
            // Check 6: First message starts at reference time
            const firstFrom = new Date(messages[0].message.from);
            (0, vitest_1.expect)(firstFrom.getTime()).toBe(referenceTime.getTime());
            // Check 7: Last message ends at reference time + 60 seconds
            const lastTo = new Date(messages[11].message.to);
            const expectedEnd = new Date(referenceTime);
            expectedEnd.setUTCSeconds(60);
            (0, vitest_1.expect)(lastTo.getTime()).toBe(expectedEnd.getTime());
        }), { numRuns: 100 });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXgudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xhbWJkYS9zZW5kZXIvaW5kZXgudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG1DQUE4QztBQUM5QywrQ0FBaUM7QUFDakMsbUNBQWtEO0FBRWxELElBQUEsaUJBQVEsRUFBQyw4QkFBOEIsRUFBRSxHQUFHLEVBQUU7SUFDMUM7Ozs7OztPQU1HO0lBQ0gsSUFBQSxXQUFFLEVBQUMsOENBQThDLEVBQUUsR0FBRyxFQUFFO1FBQ3BELEVBQUUsQ0FBQyxNQUFNLENBQ0wsRUFBRSxDQUFDLFFBQVE7UUFDUCx5REFBeUQ7UUFDekQsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxHQUFHLEVBQUUsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxFQUNyRSxDQUFDLFNBQVMsRUFBRSxFQUFFO1lBQ1YscURBQXFEO1lBQ3JELE1BQU0sYUFBYSxHQUFHLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQzFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRWxDLE1BQU0sZUFBZSxHQUFHLENBQUMsQ0FBQztZQUMxQixNQUFNLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztZQUU3QixNQUFNLFFBQVEsR0FBRyxJQUFBLCtCQUF1QixFQUNwQyxhQUFhLEVBQ2IsZUFBZSxFQUNmLGlCQUFpQixDQUNwQixDQUFDO1lBRUYsNkNBQTZDO1lBQzdDLElBQUEsZUFBTSxFQUFDLFFBQVEsQ0FBQyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUVsQyxtRUFBbUU7WUFDbkUsTUFBTSxjQUFjLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVB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LENBQUM7SUFDTixDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QgfSBmcm9tICd2aXRlc3QnO1xyXG5pbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcclxuaW1wb3J0IHsgZ2VuZXJhdGVEZWxheWVkTWVzc2FnZXMgfSBmcm9tICcuL2luZGV4JztcclxuXHJcbmRlc2NyaWJlKCdTZW5kZXIgTGFtYmRhIFByb3BlcnR5IFRlc3RzJywgKCkgPT4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiAqKkZlYXR1cmU6IGRhdGEtY29sbGVjdGlvbi1zY2hlZHVsZXIsIFByb3BlcnR5IDE6IFNlbmRlcuOBjOato+OBl+OBhOmBheW7tuOCt+ODvOOCseODs+OCueOCkueUn+aIkCoqXHJcbiAgICAgKiAqKlZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDEuMioqXHJcbiAgICAgKiBcclxuICAgICAqIEZvciBhbnkgU2VuZGVyIExhbWJkYSBleGVjdXRpb24sIHRoZSBmdW5jdGlvbiBtdXN0IGdlbmVyYXRlIGV4YWN0bHkgMTIgbWVzc2FnZXNcclxuICAgICAqIHdpdGggRGVsYXlTZWNvbmRzIHZhbHVlcyBmb3JtaW5nIHRoZSBzZXF1ZW5jZSBbMCwgNSwgMTAsIDE1LCAyMCwgMjUsIDMwLCAzNSwgNDAsIDQ1LCA1MCwgNTVdXHJcbiAgICAgKi9cclxuICAgIGl0KCdQcm9wZXJ0eSAxOiBnZW5lcmF0ZXMgY29ycmVjdCBkZWxheSBzZXF1ZW5jZScsICgpID0+IHtcclxuICAgICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYXJiaXRyYXJ5IHJlZmVyZW5jZSB0aW1lcyAobWludXRlIGJvdW5kYXJpZXMpXHJcbiAgICAgICAgICAgICAgICBmYy5kYXRlKHsgbWluOiBuZXcgRGF0ZSgnMjAyMC0wMS0wMScpLCBtYXg6IG5ldyBEYXRlKCcyMDMwLTEyLTMxJykgfSksXHJcbiAgICAgICAgICAgICAgICAodGltZXN0YW1wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIG1pbnV0ZSBib3VuZGFyeSAoMCBzZWNvbmRzLCAwIG1pbGxpc2Vjb25kcylcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VUaW1lID0gbmV3IERhdGUodGltZXN0YW1wKTtcclxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VUaW1lLnNldFVUQ1NlY29uZHMoMCwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVydmFsU2Vjb25kcyA9IDU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZXNQZXJNaW51dGUgPSAxMjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBnZW5lcmF0ZURlbGF5ZWRNZXNzYWdlcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlVGltZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxTZWNvbmRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1Blck1pbnV0ZVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIDE6IE11c3QgZ2VuZXJhdGUgZXhhY3RseSAxMiBtZXNzYWdlc1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChtZXNzYWdlcykudG9IYXZlTGVuZ3RoKDEyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgMjogRGVsYXlTZWNvbmRzIG11c3QgZm9ybSB0aGUgc2VxdWVuY2UgWzAsIDUsIDEwLCAuLi4sIDU1XVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkRGVsYXlzID0gWzAsIDUsIDEwLCAxNSwgMjAsIDI1LCAzMCwgMzUsIDQwLCA0NSwgNTAsIDU1XTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3R1YWxEZWxheXMgPSBtZXNzYWdlcy5tYXAobSA9PiBtLmRlbGF5U2Vjb25kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGFjdHVhbERlbGF5cykudG9FcXVhbChleHBlY3RlZERlbGF5cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIDM6IEVhY2ggZGVsYXkgbXVzdCBiZSBjb3JyZWN0IChpICogaW50ZXJ2YWxTZWNvbmRzKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goKG1zZywgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KG1zZy5kZWxheVNlY29uZHMpLnRvQmUoaW5kZXggKiBpbnRlcnZhbFNlY29uZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICB7IG51bVJ1bnM6IDEwMCB9XHJcbiAgICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogKipGZWF0dXJlOiBkYXRhLWNvbGxlY3Rpb24tc2NoZWR1bGVyLCBQcm9wZXJ0eSAyOiBTZW5kZXLjga7jgr/jgqTjg6DjgqbjgqPjg7Pjg4njgqbnlJ/miJDjga7mraPnorrmgKcqKlxyXG4gICAgICogKipWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAxLjIsIDIuMSoqXHJcbiAgICAgKiBcclxuICAgICAqIEZvciBhbnkgcmVmZXJlbmNlIHRpbWUgKG1pbnV0ZSBib3VuZGFyeSksIHRoZSAxMiBtZXNzYWdlcyBnZW5lcmF0ZWQgYnkgU2VuZGVyIExhbWJkYVxyXG4gICAgICogbXVzdCBlYWNoIGhhdmUgY29uc2VjdXRpdmUgNS1zZWNvbmQgdGltZSB3aW5kb3dzIHdoZXJlOlxyXG4gICAgICogLSB0byAtIGZyb20gPSA1IHNlY29uZHNcclxuICAgICAqIC0gZnJvbSA8IHRvXHJcbiAgICAgKiAtIFdpbmRvd3MgYXJlIGNvbnNlY3V0aXZlIChtZXNzYWdlW2ldLnRvID09PSBtZXNzYWdlW2krMV0uZnJvbSlcclxuICAgICAqL1xyXG4gICAgaXQoJ1Byb3BlcnR5IDI6IGdlbmVyYXRlcyBhY2N1cmF0ZSB0aW1lIHdpbmRvd3MnLCAoKSA9PiB7XHJcbiAgICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGFyYml0cmFyeSByZWZlcmVuY2UgdGltZXNcclxuICAgICAgICAgICAgICAgIGZjLmRhdGUoeyBtaW46IG5ldyBEYXRlKCcyMDIwLTAxLTAxJyksIG1heDogbmV3IERhdGUoJzIwMzAtMTItMzEnKSB9KSxcclxuICAgICAgICAgICAgICAgICh0aW1lc3RhbXApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgbWludXRlIGJvdW5kYXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlVGltZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlVGltZS5zZXRVVENTZWNvbmRzKDAsIDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlcnZhbFNlY29uZHMgPSA1O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzUGVyTWludXRlID0gMTI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gZ2VuZXJhdGVEZWxheWVkTWVzc2FnZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZVRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsU2Vjb25kcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNQZXJNaW51dGVcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKChtc2csIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb21EYXRlID0gbmV3IERhdGUobXNnLm1lc3NhZ2UuZnJvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvRGF0ZSA9IG5ldyBEYXRlKG1zZy5tZXNzYWdlLnRvKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIDE6IHRvIC0gZnJvbSA9IDUgc2Vjb25kcyAoNTAwMCBtaWxsaXNlY29uZHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdG9EYXRlLmdldFRpbWUoKSAtIGZyb21EYXRlLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlKDUwMDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgMjogZnJvbSA8IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChmcm9tRGF0ZS5nZXRUaW1lKCkpLnRvQmVMZXNzVGhhbih0b0RhdGUuZ2V0VGltZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIDM6IGZyb20gdGltZSBzaG91bGQgYmUgcmVmZXJlbmNlVGltZSArIChpbmRleCAqIGludGVydmFsU2Vjb25kcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRGcm9tID0gbmV3IERhdGUocmVmZXJlbmNlVGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkRnJvbS5zZXRVVENTZWNvbmRzKGluZGV4ICogaW50ZXJ2YWxTZWNvbmRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGZyb21EYXRlLmdldFRpbWUoKSkudG9CZShleHBlY3RlZEZyb20uZ2V0VGltZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIDQ6IHRvIHRpbWUgc2hvdWxkIGJlIHJlZmVyZW5jZVRpbWUgKyAoKGluZGV4ICsgMSkgKiBpbnRlcnZhbFNlY29uZHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVG8gPSBuZXcgRGF0ZShyZWZlcmVuY2VUaW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRUby5zZXRVVENTZWNvbmRzKChpbmRleCArIDEpICogaW50ZXJ2YWxTZWNvbmRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHRvRGF0ZS5nZXRUaW1lKCkpLnRvQmUoZXhwZWN0ZWRUby5nZXRUaW1lKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgNTogV2luZG93cyBhcmUgY29uc2VjdXRpdmUgKGV4Y2VwdCBmb3IgbGFzdCBtZXNzYWdlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBtZXNzYWdlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RnJvbURhdGUgPSBuZXcgRGF0ZShtZXNzYWdlc1tpbmRleCArIDFdLm1lc3NhZ2UuZnJvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodG9EYXRlLmdldFRpbWUoKSkudG9CZShuZXh0RnJvbURhdGUuZ2V0VGltZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayA2OiBGaXJzdCBtZXNzYWdlIHN0YXJ0cyBhdCByZWZlcmVuY2UgdGltZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0RnJvbSA9IG5ldyBEYXRlKG1lc3NhZ2VzWzBdLm1lc3NhZ2UuZnJvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGZpcnN0RnJvbS5nZXRUaW1lKCkpLnRvQmUocmVmZXJlbmNlVGltZS5nZXRUaW1lKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayA3OiBMYXN0IG1lc3NhZ2UgZW5kcyBhdCByZWZlcmVuY2UgdGltZSArIDYwIHNlY29uZHNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0VG8gPSBuZXcgRGF0ZShtZXNzYWdlc1sxMV0ubWVzc2FnZS50byk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRFbmQgPSBuZXcgRGF0ZShyZWZlcmVuY2VUaW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZEVuZC5zZXRVVENTZWNvbmRzKDYwKTtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QobGFzdFRvLmdldFRpbWUoKSkudG9CZShleHBlY3RlZEVuZC5nZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICB7IG51bVJ1bnM6IDEwMCB9XHJcbiAgICAgICAgKTtcclxuICAgIH0pO1xyXG59KTtcclxuIl19